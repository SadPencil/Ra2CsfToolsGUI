<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Xaml_Txt_HomeTabAdvancedMode" xml:space="preserve">
    <value>高级模式</value>
  </data>
  <data name="Xaml_Txt_HomeTabHeader" xml:space="preserve">
    <value>主页</value>
  </data>
  <data name="Xaml_Txt_HomeTabTextBlock1" xml:space="preserve">
    <value>本工具用于处理《红色警戒 2》及《尤里的复仇》可识别的字符串表文件（.csf），您可以：</value>
  </data>
  <data name="Xaml_Txt_HomeTabTextBlock2" xml:space="preserve">
    <value>将 .csf 文件转换为 .ini 格式，以便使用您常用的文本编辑器进行编辑，然后再转换回 .csf 文件。</value>
  </data>
  <data name="Xaml_Txt_HomeTabTextBlock3" xml:space="preserve">
    <value>您无需保留 .csf 文件。因为 .ini 文件已包含生成 .csf 文件所需的所有数据，您只需将其存储在 Git 仓库中即可。</value>
  </data>
  <data name="Xaml_Txt_HomeTabTextBlock4" xml:space="preserve">
    <value>更多功能在“高级模式”中可用……</value>
  </data>
  <data name="Xaml_Txt_HomeTabTextBlock5" xml:space="preserve">
    <value>将译文文件与上游文件并排显示，方便您对照翻译，简化了翻译过程。</value>
  </data>
  <data name="Xaml_Txt_HomeTabTextBlock6" xml:space="preserve">
    <value>突出显示新旧版本中的译文更新，让您更高效地进行修改。</value>
  </data>
  <data name="Xaml_Txt_HomeTabTextBlock7" xml:space="preserve">
    <value>如需开始，请将 .csf 或 .ini 文件拖放到此处。</value>
  </data>
  <data name="Xaml_Txt_SettingsTabHeader" xml:space="preserve">
    <value>设置</value>
  </data>
  <data name="Xaml_Txt_SettingsGroupboxHeader" xml:space="preserve">
    <value>1252 编码变通方案选项</value>
  </data>
  <data name="Xaml_Txt_SettingsTextBlock1" xml:space="preserve">
    <value>原版《红色警戒 2》的 game.fnt 文件错误地将代码点 128-159 (0x80-0x9F) 视为 Windows-1252 编码，而不是正确的 Unicode (ISO-8859-1) 编码。尽管这种处理不正确，但部分 Mod 和编辑器会以 Windows-1252 编码保存这些字符。本工具允许您选择是将这些代码点视为 Windows-1252 还是 Unicode。勾选下方两个复选框将启用 Windows-1252 变通方案，以兼容部分 Mod 和编辑器。取消勾选则使用正确的 Unicode 解释。除了商标符号（™），原版 game.fnt 文件在正确的 Unicode 代码点上都具有正确的字体数据。</value>
  </data>
  <data name="Xaml_Txt_SettingsCheckbox1" xml:space="preserve">
    <value>在加载 .csf 文件时启用 Windows-1252 变通方案。</value>
  </data>
  <data name="Xaml_Txt_SettingsCheckbox2" xml:space="preserve">
    <value>在写入 .csf 文件时启用 Windows-1252 变通方案。</value>
  </data>
  <data name="Xaml_Txt_FormatConverterTabHeader" xml:space="preserve">
    <value>格式转换器</value>
  </data>
  <data name="Xaml_Txt_FormatConverterTextBlock1" xml:space="preserve">
    <value>由于现有工具已是二十年前的产物，编辑《红色警戒 2》的字符串表文件（.csf） 既麻烦又费时。本工具可将 .csf 字符串表文件转换为易于编辑的 .ini 文件，再转换回游戏可识别的 .csf 文件。</value>
  </data>
  <data name="Xaml_Txt_FormatConverterTextBlock2" xml:space="preserve">
    <value>注意：.ini 文件必须采用 UTF-8（无 BOM）编码。</value>
  </data>
  <data name="Xaml_Txt_FormatConverterButton1_Basic" xml:space="preserve">
    <value>加载字符串表文件（.csf/.ini）...</value>
  </data>
  <data name="Xaml_Txt_FormatConverterButton1_Advanced" xml:space="preserve">
    <value>加载字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_FormatConverterButton2" xml:space="preserve">
    <value>保存为 .ini 文件...</value>
  </data>
  <data name="Xaml_Txt_FormatConverterButton3" xml:space="preserve">
    <value>保存为 .csf 文件...</value>
  </data>
  <data name="Xaml_Txt_FormatConverterButton4" xml:space="preserve">
    <value>保存为 .yaml 文件...</value>
  </data>
  <data name="Xaml_Txt_FormatConverterButton5" xml:space="preserve">
    <value>保存为 .json 文件...</value>
  </data>
  <data name="Xaml_Txt_FormatConverterTextBlock3" xml:space="preserve">
    <value>下方预览框显示了字符串表内容。如需修改，请先将其保存为 .ini 文件。</value>
  </data>
  <data name="Xaml_Txt_LabelOverrideTabHeader" xml:space="preserve">
    <value>标签覆盖</value>
  </data>
  <data name="Xaml_Txt_LabelOverrideTextBlock1" xml:space="preserve">
    <value>本工具现已支持包含大写字母的标签名称。选择一个上游文件和您的当前文件，本工具将忽略大小写比较每个标签，并优先使用来自上游文件的标签。</value>
  </data>
  <data name="Xaml_Txt_LabelOverrideButton1" xml:space="preserve">
    <value>加载上游字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_LabelOverrideButton2" xml:space="preserve">
    <value>加载当前字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_LabelOverrideButton3" xml:space="preserve">
    <value>保存为 .csf 文件...</value>
  </data>
  <data name="Xaml_Txt_LabelOverrideButton4" xml:space="preserve">
    <value>保存为 .ini 文件...</value>
  </data>
  <data name="Xaml_Txt_LabelCheckTabHeader" xml:space="preserve">
    <value>标签检查</value>
  </data>
  <data name="Xaml_Txt_LabelCheckTextBlock1" xml:space="preserve">
    <value>检查您的地图文件中是否缺少 .csf 标签。</value>
  </data>
  <data name="Xaml_Txt_LabelCheckButton1" xml:space="preserve">
    <value>加载字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_LabelCheckButton2" xml:space="preserve">
    <value>选择包含地图文件（.map/.mpr/.yrm）的文件夹...</value>
  </data>
  <data name="Xaml_Txt_LabelCheckTextboxHeader" xml:space="preserve">
    <value>注意：在生成的 .ini 文件中，所有缺失标签的值都将替换为以下文本：</value>
  </data>
  <data name="Xaml_Txt_LabelCheckButton3" xml:space="preserve">
    <value>保存为 .ini 文件...</value>
  </data>
  <data name="Xaml_Txt_TranslationNewTabHeader" xml:space="preserve">
    <value>翻译助手 - 新建</value>
  </data>
  <data name="Xaml_Txt_TranslationNewTextBlock1" xml:space="preserve">
    <value>选择一个上游文件，并将其保存为便于翻译的 .ini 文件。您可以在“格式转换器”选项卡中将此 .ini 文件转换回 .csf 文件。</value>
  </data>
  <data name="Xaml_Txt_TranslationNewTextboxHeader" xml:space="preserve">
    <value>注意：在生成的 .ini 文件中，所有需要翻译的值都将替换为以下文本：</value>
  </data>
  <data name="Xaml_Txt_TranslationNewButton1" xml:space="preserve">
    <value>加载上游字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_TranslationNewButton2" xml:space="preserve">
    <value>保存为 .ini 文件以供翻译...</value>
  </data>
  <data name="Xaml_Txt_TranslationTileTabHeader" xml:space="preserve">
    <value>翻译助手 - 并排</value>
  </data>
  <data name="Xaml_Txt_TranslationTileTextBlock1" xml:space="preserve">
    <value>选择一个上游文件和一个译文文件，然后保存一个便于比较和检查的新 .ini 文件。您可以在“格式转换器”选项卡中将此 .ini 文件转换回 .csf 文件。</value>
  </data>
  <data name="Xaml_Txt_TranslationTileButton1" xml:space="preserve">
    <value>加载上游字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_TranslationTileButton2" xml:space="preserve">
    <value>加载译文的字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_TranslationTileButton3" xml:space="preserve">
    <value>保存为 .ini 文件以供比较...</value>
  </data>
  <data name="Xaml_Txt_TranslationOverrideTabHeader" xml:space="preserve">
    <value>翻译助手 - 覆盖</value>
  </data>
  <data name="Xaml_Txt_TranslationOverrideTextBlock1" xml:space="preserve">
    <value>选择一个上游文件和一个译文文件。本工具将保存一个 .ini 文件，该文件将优先使用译文文件中的值，否则将使用上游文件中的值。您可以在“格式转换器”选项卡中将此 .ini 文件转换回 .csf 文件。</value>
  </data>
  <data name="Xaml_Txt_TranslationOverrideButton1" xml:space="preserve">
    <value>加载上游字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_TranslationOverrideButton2" xml:space="preserve">
    <value>加载译文的字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_TranslationOverrideButton3" xml:space="preserve">
    <value>保存为 .ini 文件以供比较...</value>
  </data>
  <data name="Xaml_Txt_TranslationUpdateTabHeader" xml:space="preserve">
    <value>翻译助手 - 更新</value>
  </data>
  <data name="Xaml_Txt_TranslationUpdateTextBlock1" xml:space="preserve">
    <value>选择旧版上游文件、新版上游文件和旧版译文文件。本工具将保存一个方便您更新译文的新 .ini 文件。您可以在“格式转换器”选项卡中将此 .ini 文件转换回 .csf 文件。</value>
  </data>
  <data name="Xaml_Txt_TranslationUpdateButton1" xml:space="preserve">
    <value>加载旧版上游字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_TranslationUpdateButton2" xml:space="preserve">
    <value>加载新版上游字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_TranslationUpdateButton3" xml:space="preserve">
    <value>加载旧版译文的字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_TranslationUpdateButton4" xml:space="preserve">
    <value>保存为 .ini 文件以供更新译文...</value>
  </data>
  <data name="Xaml_Txt_TranslationUpdateCheckTabHeader" xml:space="preserve">
    <value>翻译助手 - 更新检查</value>
  </data>
  <data name="Xaml_Txt_TranslationUpdateCheckTextBlock1" xml:space="preserve">
    <value>选择旧版上游文件、新版上游文件、旧版译文文件和新版译文文件。本工具将保存一个新 .ini 文件，用于检查是否有标签仍保留旧的翻译。您可以在“格式转换器”选项卡中将此 .ini 文件转换回 .csf 文件。</value>
  </data>
  <data name="Xaml_Txt_TranslationUpdateCheckButton1" xml:space="preserve">
    <value>加载旧版上游字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_TranslationUpdateCheckButton2" xml:space="preserve">
    <value>加载新版上游字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_TranslationUpdateCheckButton3" xml:space="preserve">
    <value>加载旧版译文的字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_TranslationUpdateCheckButton4" xml:space="preserve">
    <value>加载新版译文的字符串表文件（.csf/.ini/.yaml/.json）...</value>
  </data>
  <data name="Xaml_Txt_TranslationUpdateCheckButton5" xml:space="preserve">
    <value>保存为 .ini 文件以供更新译文...</value>
  </data>
  <data name="Xaml_Txt_WatchModeTabHeader" xml:space="preserve">
    <value>监视模式</value>
  </data>
  <data name="Xaml_Txt_WatchModeTextBlock1" xml:space="preserve">
    <value>在下方文本框中，输入要监视的 .ini (.ini/.yaml/.json) 文件及其对应的 .csf 文件，两者之间用逗号分隔。每一行对应一对文件。启动后，本程序将自动监视 .ini (.ini/.yaml/.json) 文件，一旦检测到更改，便自动生成对应的 .csf 文件。</value>
  </data>
  <data name="Xaml_Txt_WatchModeTextBlock2" xml:space="preserve">
    <value>示例：C:\path\to\stringtables\ra2.ini, D:\path\to\game\ra2.csf</value>
  </data>
  <data name="Xaml_Txt_WatchModeButton1" xml:space="preserve">
    <value>保存并应用</value>
  </data>
  <data name="Cs_Txt_Error" xml:space="preserve">
    <value>错误</value>
  </data>
  <data name="Cs_Txt_FileContainsLabelsAndLanguage" xml:space="preserve">
    <value>此字符串表文件包含 {0} 个标签，语言为 {1}。</value>
  </data>
  <data name="Cs_Txt_UnexpectedFileExtension" xml:space="preserve">
    <value>文件扩展名不正确。仅支持 .csf、.ini、.yaml 和 .json 文件。</value>
  </data>
  <data name="Cs_Txt_FileFilter" xml:space="preserve">
    <value>字符串表文件 (.csf;.ini;.yaml;.json)|.csf;.ini;.yaml;.json|Westwood RA2 字符串表文件 (.csf)|.csf|SadPencil.Ra2CsfFile.Ini 文件 (.ini)|.ini|SadPencil.Ra2CsfFile.Yaml 文件 (.yaml)|.yaml|JSON 文件 (.json)|.json</value>
  </data>
  <data name="Cs_Txt_FileLoadedSuccessfully" xml:space="preserve">
    <value>文件加载成功。此字符串表包含 {0} 个标签，语言为 {1}。</value>
  </data>
  <data name="Cs_Txt_Success" xml:space="preserve">
    <value>成功</value>
  </data>
  <data name="Cs_Txt_FileSavedSuccessAndOpenFolder" xml:space="preserve">
    <value>文件保存成功。是否在文件资源管理器中打开此文件？</value>
  </data>
  <data name="Cs_Txt_LoadFileFirst" xml:space="preserve">
    <value>请先加载一个字符串表文件。</value>
  </data>
  <data name="Cs_Txt_CsfFilter" xml:space="preserve">
    <value>Westwood RA2 字符串表文件 (*.csf)|*.csf</value>
  </data>
  <data name="Cs_Txt_IniFilter" xml:space="preserve">
    <value>SadPencil.Ra2CsfFile.Ini 文件 (*.ini)|*.ini</value>
  </data>
  <data name="Cs_Txt_YamlFilter" xml:space="preserve">
    <value>SadPencil.Ra2CsfFile.Yaml 文件 (*.yaml)|*.yaml</value>
  </data>
  <data name="Cs_Txt_JsonFilter" xml:space="preserve">
    <value>JSON 文件 (*.json)|*.json</value>
  </data>
  <data name="Cs_Txt_LoadFilesFirst" xml:space="preserve">
    <value>请先加载字符串表文件。</value>
  </data>
  <data name="Cs_Txt_ChangesSaved" xml:space="preserve">
    <value>您的更改已成功保存。</value>
  </data>
  <data name="Cs_Txt_InvalidWatchConfig" xml:space="preserve">
    <value>无效的监视配置行：{0}</value>
  </data>
  <data name="Cs_Txt_DragAndDropSingleFile" xml:space="preserve">
    <value>一次只能拖放一个文件。</value>
  </data>
  <data name="Cs_Txt_WatchModeConfirm" xml:space="preserve">
    <value>监视模式已配置。是否启动？</value>
  </data>
  <data name="Cs_Txt_Information" xml:space="preserve">
    <value>信息</value>
  </data>
  <data name="Cs_Txt_SelectMapFolderFirst" xml:space="preserve">
    <value>请先选择地图文件夹。</value>
  </data>
  <data name="Cs_Txt_FolderDoesNotExist" xml:space="preserve">
    <value>文件夹 {0} 不存在！</value>
  </data>
  <data name="Cs_Txt_InvalidCharactersInLabelName" xml:space="preserve">
    <value>在标签名称 "{0}" 中发现无效字符。</value>
  </data>
  <data name="Cs_Txt_FailedToReadMapFile" xml:space="preserve">
    <value>读取地图文件 {0} 失败：{1}</value>
  </data>
  <data name="Cs_Txt_LabelCheckResult" xml:space="preserve">
    <value>已检查 {0} 个地图文件，共找到 {1} 个不同的标签，其中 {2} 个缺失。</value>
  </data>
  <data name="Cs_Txt_Result" xml:space="preserve">
    <value>结果</value>
  </data>
  <data name="Cs_Txt_LabelCheckLabel0Warning" xml:space="preserve">
    <value>有件事您该注意。有一个名为“0”的标签。</value>
  </data>
</root>